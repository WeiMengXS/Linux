双向链表组织    操作系统是使用双线链表来组织PCB进程。
OUT
./OUT
运行后挂在双向链表后

由内核组织    PCB<--->PCB。。

pid_t fork（void）；
pid_t gfork ==>int类型
  失败：返回-1
  成功：返回0返回给子进程，返回大于0（返回子进程的pid）返回给父进程。、

没有内存的时候 失败  得知道 创建需要内核空间
fork要讲FORK返回值大于0的情况下返回给父亲的逻辑

思考。如果FORK把等于0的情况返回给副进程的逻辑是否可行

进程状态；
  R。运行状态
   前台进程  ./可执行程序                                           +前台进程  
   后台进程  将进程变成后台进程
 S。睡眠状态
  D磁盘睡眠状态
 T暂停状态   ctrl+z
 t：跟踪状态   jdb调试状态
 Z（zombie）：僵尸状态
 X：死亡状态，
 孤儿进程：并非进程状态而是进程的种类==》产生原因，是由于父进程先于子进程先退出，导致子进程需要将自己的退出状态信息返回给一个进程
   这个进程通常是操作系统的一号进程，也就称为INIT进程。它本身就会创建许多进程，本身INit进程创建的子进程我们不能把他称为孤儿进程


  如何产生僵尸状态？


由于子进程推出，但是父进程没有回收子进程退出状态，导致子进程变成僵尸状态


      危害。PCB一直释放不了，占用内存一直是放不了  内存泄漏。双向链表中挂着；  ps aux 这个命令能够看到
  如果大量的僵尸进程越多，内存泄漏越多。

如何解决和防止僵尸进程？


1.草率的做法，将僵尸进程的父进程杀掉，僵尸进程则变成了孤儿进程，被一号回收进程返回信息。同时内核在当中释放孤儿进程。


							EVN命令：查看环境变量的

                                          环境变量

                 b。常见的环境变量
                 		PATH：查看可执行程序的变量
                                                Home:保存是当前用户家目录
			SHELL：保存当前使用的SHELL的环境变量
			LD_LIBrary_PATH:程序运行时，库文件搜索路径
			Library：程序编译的时候。库文件的搜索路径的环境变量



   c。常见的命令
     env：查看当前操作系统当中


