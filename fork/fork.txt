1进程控制，
   1进程创建   2进程终止 3进程等待 4进程程序替换

fork：

    1vfork创建的子进程，也是拷贝父执行亲的PC‘父子B但是i进程的PCB
  进程终止就是让一个进程退出
     b。场景：
   		从main函数也退出了，但是呢，结果是不正确的
		从main函数退出了，并且结果是正确的’
		进程异常终止了
   c。程序退出的方法‘
		1,main函数return；
		2.exit库函数  echo&? 查看atexit（func）
		4._exit.  系统调用
          解引用空指针  ctrl―+c  内存访问越界   《-  异常退出。

  	进程等待：  为了防止僵尸进程的产生
echo&？：-1	    pid_t wait（int *status）;
		status 是一个出参，供调用者获取子进程的推出状态（切记，不是推出码）
		返回值：如果成功，则返回子进程的pid
		失败返回-1；
     调用wait会导致父进程陷入阻塞状态，直到有一个。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。

  	0	阻塞：当调用函数需要等待一定条件成熟的时候，如果条件不成熟，则一直等待，如果条件成熟，则函数逻辑之后
正常返回，
		非阻塞：当调用函数需要一定条件的时候，如果条件不成熟，直接返回。如果成熟直接执行调用逻辑后返回
3进程等待   ‘
		a为了防止僵尸进程
 		wait
		waitpid（）

pid=-1 等待任意子进程
pid》0  等待子进程ID号